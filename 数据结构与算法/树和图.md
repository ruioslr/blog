---
title: 树和图
categories:
  - 数据结构与算法
tags:
  - 数据结构与算法
---

# 树和图

## 树

### 定义：树（Tree）是 n（n≥0）个结点的有限集，它或为空树（n=0）；或为非空树，对于非空树 T：

-（1）有且仅有一个称之为根的结点； -（2）除根结点以外的其余结点可分为 m（m>0）个互不相交的有限集 T1, T2,…, Tm,其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

### 术语

- 节点： 树中的一个独立单元。包含一个数据元素及若干指向其子树的分支。
- 节点的度： 节点拥有的子树数（分支数）。
- 数的度： 各个几点的度的最大值。
- 叶子： 度为 0 的节点。
- 树的深度：树中结点的最大层次称为树的深度或高度。
- 森林：是 m（m≥0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。

就逻辑结构而言，任何一棵树都是一个二元组 Tree ＝(root , F)，其中 root 是数据元素，称作树的根结点；F 是 m（m≥0）棵树的森林，F=(T1, T2, …, Tm)，其中 Ti=(ri, Fi)称作根 root 的第 i 棵子树；当 m≠0 时，在树根和其子树森林之间存在下列关系：

```
RF={<root,ri>|i=1,2,…,m,m>0
```

## 二叉树

二叉树与树的区别：

- 二叉树每个结点至多只有两棵子树（即二叉树中不存在度大于 2 的结点）；
- 二叉树的子树有左右之分，其次序不能任意颠倒。

### 二叉树的性质

- 在二叉树的第 i 成上最多有 2^(i-1)个节点, i >= 1。
- 深度为 k 的二叉树最多有 2^k - 1 个节点。
- 叶子节点数 n0,与度为 2 的节点 n2 的关系是： **n0 = n2 + 1**;

### 完全二叉树和满二叉树

**满二叉树**： 一棵深度为 k 且有 2^k - 1 个借点的二叉树称为满二叉树。

**完全二叉树**： 深度为 k，有 n 个节点的二叉树，当且仅当其每一个结点都与深度为 k 的**满二叉树**中编号从 1 至 n 的结点一一对应。

性质：

- 具有 n 个节点的完全二叉树的深度（log2 n） + 1

### 二叉树的存储结构

- 顺序存储结构
- 链式存储结构

**顺序存储结构**： 最坏的情况下，深度为 k 且只有 k 个节点的单只树却需要 2^k -1 长度的一维数组。

#### 链式存储结构

包含左右指针和数据域称为**二叉链表**。

在二叉链表的基础上添加 parent 指针即为**三叉链表**。

在含有 n 的节点的二叉链表中有**n + 1 个空链域**。

### 二叉树的遍历

- 先（根）序遍历
- 中（根）序遍历
- 后（根）序遍历： 可用于求二叉树的深度
- 层序遍历：使用队列
  ::: tip
  遍历是递归的， 但可以使用栈来将递归算法转换成非递归算法，无论何种算法，时间复杂度都是 O(n)，空间复杂度最坏的情况，即数据节点数是树的深度，也是 O(n)。
  :::

### 线索二叉树

若节点有左子树，则其 lchild 指向左子树，否则指向前驱，若有右子树，则指向右子树，否则指向后继。这样的树称为**线索二叉树**。

以某种次序遍历使二叉树变成线索二叉树的过程称为**线索化**。

## 树和深林

### 树的存储结构

- 双亲表示法
- 孩子表示法
- 孩子兄弟表示法： 也叫**二叉链表表示法** 。以二叉链表为存储结构，两个指针域分别指向 firstChild 和 nextSibling。react 的 fiber Tree 在这个基础上在加了一个 return 指向 parent。

### 树，深林与二叉树的转换

#### 树和二叉树的转换

树 -> 二叉树

- 1，加线： 兄弟节点加线
- 2，抹线： 抹去每个节点除左孩子的线
- 3，旋转： 顺时针旋转 45°

二叉树 -> 树

- 1，加线： 将节点的父节点与节点的所有子孙节点连线
- 2，抹线： 抹掉原二叉树中父节点与右子节点的连线

#### 深林转换成二叉树

如果 F={T1, T2,…, Tm}是森林，则可按如下规则转换成一棵二叉树 B=(root, LB,RB)。 -（1）若 F 为空，即 m=0，则 B 为空树； -（2）若 F 非空，即 m≠0，则 B 的根 root 即为森林中第一棵树的根 ROOT(T1)；B 的左子树 LB 是从 T1 中根结点的子树森林 F1={T11, T12,…, T1m}转换而成的二叉树；其右子树 RB 是从森林 F′={T2, T3, …, Tm}转换而成的二叉树。

#### 二叉树转换成深林

如果 B=(root, LB, RB)是一棵二叉树，则可按如下规则转换成森林 F={T1,T2，…, Tm}： -（1）若 B 为空，则 F 为空； -（2）若 B 非空，则 F 中第一棵树 T1 的根 ROOT(T1)即为二叉树 B 的根 root；T1 中根结点的子树森林 F1 是由 B 的左子树 LB 转换而成的森林；F 中除 T1 之外其余树组成的森林 F′={T2, T3,…, Tm}是由 B 的右子树 RB 转换而成的森林。

从上述递归定义容易写出相互转换的递归算法。同时，森林和树的操作亦可转换成二叉树的操作来实现。

### 树和深林的遍历

#### 树的遍历

- 先根遍历: 与其转换成的二叉树的**先序遍历保持一致**
- 后根遍历：与其转换的二叉树的**中序遍历保持一致**

深林的遍历即为每棵树的依次遍历。

关系：
|树 | 深林 | 二叉树 | 图 |
| ---- | ---- | ---- | ---- |
|先根遍历 | 先序遍历 | 先序遍历 | DFS |
|后根遍历 | 中序遍历 | 中序遍历 | |
|层次遍历 | | | BFS |

### 赫夫曼树及其应用

又叫**最优二叉树**，是一种带权路径长度最短的树。

定义：假设有以 m 个权值{w1, w2,…, wm}，可以构造一棵含 n 个叶子结点的二叉树，每个叶子结点的权为 wi，则其中带权路径长度 WPL 最小的二叉树称做最优二叉树或哈夫曼树

特征：

- 1，完全二叉树并不一定是 Huffman 树
- 2，在哈夫曼树中，权值大的节点离根近
- 3，哈夫曼树中不唯一，但带权路径长度 WPL 一定相等

赫夫曼算法：

- （1）根据给定的 n 个权值{w1, w2,…, wn}，构造 n 棵只有根结点的二叉树，这 n 棵二叉树构成一个森林 F。-
- （2）在森林 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。
- （3）在森林 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。
- （4）重复（2）和（3），直到 F 只含一棵树为止。这棵树便是哈夫曼树。

::: tip

在构造哈夫曼树时，首先选择权小的，这样保证权大的离根较近，这样一来，在计算树的带权路径长度时，自然会得到最小带权路径长度，这种生成算法是一种典型的贪心法。

:::

#### 哈夫曼编码

也叫**最小冗余码**

## 图

图（Graph）G 由两个集合 V 和 E 组成，记为 G=(V, E)，其中 V 是顶点的有穷非空集合，E 是 V 中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和 E(G)通常分别表示图 G 的顶点集合和边集合，E(G)可以为空集。若 E(G)为空，则图 G 只有顶点而没有边。

对于无向图，若具有**n(n−1)/2**条边，则称为无向完全图。对于有向图，若具有**n(n−1)**条弧，则称为有向完全图。

**权和网**：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为**网**。

**弧**： 有向边即为弧，对于有向边<a, b>, a 是**弧尾**， b 是**弧头**。

### 图的存储结构

- 数组
- 邻接表
- 十字链表
- 领结多重表

### 图的遍历

- 深度优先搜索（DFS）: 类似于树的**先根遍历**
- 广度优先搜索（BFS）: 类似于树的**层次遍历**
